from queue import Queue
import threading

# coordinates messages
# some of the code is still copy paste from a tutorial

class Event(object):
    """
    A superclass for any event generated by an
    object and sent to EventManager.
    """

    def __init__(self):
        self.name = "Event"

    def __str__(self):
        return self.name


class QuitEvent(Event):

    def __init__(self):
        self.name = "Quit event"


class InputEvent(Event):
    """
    Input event (keyboard/mouse).
    """

    def __init__(self, unicodechar, clickpos):
        self.name = "Input event"
        self.char = unicodechar
        self.clickpos = clickpos

    def __str__(self):
        return '%s, char=%s, clickpos=%s' % (self.name, self.char, self.clickpos)

class RemoveListenerEvent(Event):
    def __init__(self, listener):
        self.name = "Remove listener event"
        self.listener = listener

class AddListenerEvent(Event):
    def __init__(self, listener):
        self.name = "Add listener event"
        self.listener = listener

class BroadcastEvent(Event):
    def __init__(self, target, payload):
        self.name = "Broadcast event"
        self.target = target
        self.payload = payload

class ReplyEvent(Event):
    def __init__(self, target, payload):
        self.name = "Reply event"
        self.target = target
        self.payload = payload

class ChangeViewEvent(Event):
    def __init__(self, view):
        self.name = "ChangeView event"
        self.view = view

class RequestQueueEvent(Event):
    def __init__(self):
        self.name = "RequestQueue event"

class ReadBoardEvent(Event):
    def __init__(self):
        self.name = "ReadBoard event"

class UpdateBoardEvent(Event):
    def __init__(self, x, y, payload):
        self.x = x
        self.y = y
        self.payload = payload
        self.name = "UpdateBoard event"

class BoardStateEvent(Event):
    def __init__(self, payload, winning_rows):
        self.payload = payload
        self.winning_rows = winning_rows
        self.name = "BoardState event"

class BoardClickedEvent(Event):
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.name = "BoardClicked event"

class ResetViewEvent(Event):
    def __init__(self):
        self.name = "ResetView event"

class ResetBoardEvent(Event):
    def __init__(self):
        self.name = "Board event"

class EventManager(object):
    """
    Coordinate communication between various parts of the program.
    Use thread-safe queue object to order events.
    Commit to delivering all events between registration and unregistration.
    """

    def __init__(self):
        self.listeners = set()
        self.queue = Queue()

    def RegisterListener(self, listener):
        """ 
        Adds a listener to our spam list. 
        It will receive Post()ed events through it's notify(event) call. 
        """

        self.queue.put(AddListenerEvent(listener))

    def UnregisterListener(self, listener):
        """ 
        Remove a listener from our spam list.
        This is implemented but hardly used.
        Our weak ref spam list will auto remove any listeners who stop existing.
        """

        self.queue.put(RemoveListenerEvent(listener))

    def Post(self, event):
        """
        Post a new event to the message queue.
        """

        self.queue.put(event)

    def StartNotifying(self):
        def subfunction():
            while True:
                event = self.queue.get()

                # These relate to managing the queue and are internal

                if isinstance(event, RemoveListenerEvent):
                    self.listeners.remove(event.listener)
                if isinstance(event, AddListenerEvent):
                    self.listeners.add(event.listener)

                # These are actually broadcast

                else:
                    for listener in self.listeners:
                        listener.notify(event)

        t = threading.Thread(target=subfunction)
        t.start()

        self.Post("E: Started event manager")
